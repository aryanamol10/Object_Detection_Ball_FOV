import cv2
import numpy as np
import math
import threading
from collections import deque
from ultralytics import YOLO
from scipy.cluster.hierarchy import fclusterdata

# --- SETTINGS ---
IMG_WIDTH, IMG_HEIGHT = 1280, 720
MAP_SIZE = 600
FIELD_METERS_V = 10
FIELD_METERS_H = 8
CLUSTER_THRESHOLD = 0.5
SMOOTHING_FRAMES = 5  # Number of frames to average (higher = smoother, but more lag)

# Dictionary to store the history of each tracked ball {id: deque([pos1, pos2...])}
ball_history = {}

class VideoStream:
    def __init__(self, src=2):
        self.cap = cv2.VideoCapture(src, cv2.CAP_DSHOW)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, IMG_WIDTH)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, IMG_HEIGHT)
        self.ret, self.frame = self.cap.read()
        self.stopped = False

    def start(self):
        threading.Thread(target=self.update, daemon=True).start()
        return self

    def update(self):
        while not self.stopped:
            self.ret, self.frame = self.cap.read()

    def read(self):
        return self.frame

    def stop(self):
        self.stopped = True
        self.cap.release()

def map_points_fast(cx, cy):
    RAD_H = math.radians(92.1)
    RAD_V = math.radians(60.6)
    BALL_R = 0.075057
    CAM_H = 1.441176
    
    thetay = ((IMG_HEIGHT / 2) - cy) * (RAD_V / IMG_HEIGHT)
    thetax = (cx - (IMG_WIDTH / 2)) * (RAD_H / IMG_WIDTH)
    
    d_forward = (CAM_H - BALL_R) / math.tan(max(0.05, thetay))
    d_side = d_forward * math.tan(thetax)
    return d_side, d_forward

def draw_field_map(singles, clusters):
    map_img = np.zeros((MAP_SIZE, MAP_SIZE, 3), dtype=np.uint8)
    # Draw simple FRC-style grid
    for i in range(1, 6):
        y = MAP_SIZE - int((i*2 / FIELD_METERS_V) * MAP_SIZE)
        cv2.line(map_img, (0, y), (MAP_SIZE, y), (80, 80, 80), 1)
    
    # Draw center line
    cv2.line(map_img, (MAP_SIZE//2, 0), (MAP_SIZE//2, MAP_SIZE), (100, 100, 100), 1)

    for s, f in singles:
        mx = int((s + FIELD_METERS_H/2) / FIELD_METERS_H * MAP_SIZE)
        my = MAP_SIZE - int((f / FIELD_METERS_V) * MAP_SIZE)
        if 0 <= mx < MAP_SIZE and 0 <= my < MAP_SIZE:
            cv2.circle(map_img, (mx, my), 8, (0, 255, 255), -1)

    for s, f in clusters:
        mx = int((s + FIELD_METERS_H/2) / FIELD_METERS_H * MAP_SIZE)
        my = MAP_SIZE - int((f / FIELD_METERS_V) * MAP_SIZE)
        if 0 <= mx < MAP_SIZE and 0 <= my < MAP_SIZE:
            cv2.drawMarker(map_img, (mx, my), (255, 0, 255), cv2.MARKER_SQUARE, 20, 3)
            
    return map_img

# --- MAIN ---
model = YOLO("PyTorch_model.pt")
vs = VideoStream(2).start()

while True:
    frame = vs.read()
    if frame is None: continue

    # Use .track() instead of .predict() to get persistent IDs
    results = model.track(frame, persist=True, tracker="bytetrack.yaml", verbose=False)
    
    current_frame_coords = []
    
    if results[0].boxes.id is not None:
        boxes = results[0].boxes.xywh.cpu().numpy()
        ids = results[0].boxes.id.int().cpu().numpy()

        for box, obj_id in zip(boxes, ids):
            cx, cy, w, h = box
            # Use bottom-center for distance mapping
            raw_side, raw_forward = map_points_fast(cx, cy + (h/2))

            # --- SMOOTHING LOGIC ---
            if obj_id not in ball_history:
                ball_history[obj_id] = deque(maxlen=SMOOTHING_FRAMES)
            
            ball_history[obj_id].append((raw_side, raw_forward))
            
            # Calculate the average of the last N frames for this specific ID
            avg_side = sum(p[0] for p in ball_history[obj_id]) / len(ball_history[obj_id])
            avg_forward = sum(p[1] for p in ball_history[obj_id]) / len(ball_history[obj_id])
            
            current_frame_coords.append([avg_side, avg_forward])

            # Draw visual ID and stable position on the frame
            cv2.putText(frame, f"ID:{obj_id}", (int(cx-w/2), int(cy-h/2)-10), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
            cv2.rectangle(frame, (int(cx-w/2), int(cy-h/2)), (int(cx+w/2), int(cy+h/2)), (0, 255, 0), 2)

    # Cleanup: Remove IDs that haven't been seen in a while (optional)
    if len(ball_history) > 50: # Simple cap to prevent memory leak
        ball_history.clear()

    # Clustering & Mapping
    singles, clusters = [], []
    if len(current_frame_coords) >= 2:
        pts = np.array(current_frame_coords)
        z = fclusterdata(pts, t=CLUSTER_THRESHOLD, criterion='distance')
        u, counts = np.unique(z, return_counts=True)
        for i, count in zip(u, counts):
            group = pts[z == i]
            if count >= 2: clusters.append(np.mean(group, axis=0))
            else: singles.append(group[0])
    else:
        singles = current_frame_coords

    field_map = draw_field_map(singles, clusters)
    cv2.imshow("FRC Stable Feed", frame)
    cv2.imshow("Field Map", field_map)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        vs.stop()
        break

cv2.destroyAllWindows()