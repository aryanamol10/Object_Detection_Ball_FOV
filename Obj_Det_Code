import cv2
import numpy as np
import math
import threading
from ultralytics import YOLO
from scipy.cluster.hierarchy import fclusterdata

# --- SETTINGS ---
IMG_WIDTH, IMG_HEIGHT = 1280, 720
MAP_SIZE = 500
FIELD_METERS_V = 10 
FIELD_METERS_H = 6 
CLUSTER_THRESHOLD = 0.6 

# --- THREADED CAMERA CLASS ---
class VideoStream:
    def __init__(self, src=2):
        self.cap = cv2.VideoCapture(src, cv2.CAP_DSHOW)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, IMG_WIDTH)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, IMG_HEIGHT)
        self.ret, self.frame = self.cap.read()
        self.stopped = False

    def start(self):
        threading.Thread(target=self.update, args=(), daemon=True).start()
        return self

    def update(self):
        while not self.stopped:
            self.ret, self.frame = self.cap.read()

    def read(self):
        return self.frame

    def stop(self):
        self.stopped = True
        self.cap.release()

# --- MATH HELPER ---
def map_points_fast(cx, cy):
    RAD_H = math.radians(92.1)
    RAD_V = math.radians(60.6)
    BALL_R = 0.075
    CAM_H = 1.44
    
    thetay = ((IMG_HEIGHT / 2) - cy) * (RAD_V / IMG_HEIGHT)
    thetax = (cx - (IMG_WIDTH / 2)) * (RAD_H / IMG_WIDTH)
    
    d_forward = (CAM_H - BALL_R) / math.tan(max(0.05, thetay))
    d_side = d_forward * math.tan(thetax)
    return d_side, d_forward

def draw_field_map(coords, clusters):
    """Draws a high-speed top-down view using OpenCV instead of Matplotlib"""
    map_img = np.zeros((MAP_SIZE, MAP_SIZE, 3), dtype=np.uint8)

    for i in range(1, 5):
        y = MAP_SIZE - int((i*2 / FIELD_METERS_V) * MAP_SIZE)
        cv2.line(map_img, (0, y), (MAP_SIZE, y), (50, 50, 50), 1)

    for s, f in coords:
        mx = int((s + FIELD_METERS_H/2) / FIELD_METERS_H * MAP_SIZE)
        my = MAP_SIZE - int((f / FIELD_METERS_V) * MAP_SIZE)
        if 0 <= mx < MAP_SIZE and 0 <= my < MAP_SIZE:
            cv2.circle(map_img, (mx, my), 5, (0, 255, 255), -1)

    for s, f in clusters:
        mx = int((s + FIELD_METERS_H/2) / FIELD_METERS_H * MAP_SIZE)
        my = MAP_SIZE - int((f / FIELD_METERS_V) * MAP_SIZE)
        if 0 <= mx < MAP_SIZE and 0 <= my < MAP_SIZE:
            cv2.drawMarker(map_img, (mx, my), (255, 0, 255), cv2.MARKER_CROSS, 15, 2)
            
    return map_img

# --- MAIN ---
model = YOLO("PyTorch_model.pt")
vs = VideoStream(2).start()

while True:
    frame = vs.read()
    if frame is None: continue

    # Optimization: Lower resolution for YOLO if still laggy
    # results = model.predict(frame, imgsz=320, verbose=False)
    results = model.predict(frame, verbose=False, conf=0.7)
    
    detected_coords = []
    
    # Process detections
    for result in results:
        boxes = result.boxes.xywh.cpu().numpy() # Center X, Center Y, Width, Height
        for box in boxes:
            cx, cy, w, h = box
            # Skip expensive contour fitting unless necessary; 
            # for speed, use the bottom-center of the YOLO box
            d_side, d_forward = map_points_fast(cx, cy + (h/2))
            detected_coords.append([d_side, d_forward])
            
            # Draw box on main feed
            cv2.rectangle(frame, (int(cx-w/2), int(cy-h/2)), (int(cx+w/2), int(cy+h/2)), (0, 255, 0), 2)

    # Fast Clustering
    singles, cluster_centers = [], []
    if len(detected_coords) >= 2:
        pts = np.array(detected_coords)
        z = fclusterdata(pts, t=CLUSTER_THRESHOLD, criterion='distance')
        u, counts = np.unique(z, return_counts=True)
        for i, count in zip(u, counts):
            group = pts[z == i]
            if count >= 2: cluster_centers.append(np.mean(group, axis=0))
            else: singles.append(group[0])
    else:
        singles = detected_coords

    # Visuals
    field_map = draw_field_map(singles, cluster_centers)
    cv2.imshow("Main Feed", frame)
    cv2.imshow("Field Map", field_map)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        vs.stop()
        break

cv2.destroyAllWindows()